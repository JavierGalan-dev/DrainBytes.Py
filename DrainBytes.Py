#!/usr/bin/python3
# -*- coding: iso-8859-15 -*-
#
# This script is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This script is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) [2022] [Javier Galán] [www.javiergalanrico.com/]
#
## DrainBytes.Py
# v0.1
#
# DrainBytes.Py <fileinput> <patcharrayfile> <interval> <mode> <fileoutput>
#
# DrainBytes restores in the given time interval a glitched file by taking the original bytes
# generated by DataMosher.Py with the -pa <outfile> flag
#
# The restoring order can be delivered with this available modes:
#
#	fw (forward) <--default	
#	bw (backward)		
#	rnd (random)		
#
#

import sys
import io
import time
import keyboard
from random import shuffle

	
print ("DrainBytes.Py")

if len(sys.argv) == 6 :

	i = sys.argv[1]
	p = sys.argv[2]
	t = float(sys.argv[3])
	m = sys.argv[4]
	o = sys.argv[5]
	

elif len(sys.argv) != 6:

	print("Incorrect argument number")
	print("Use: DrainBytes.Py <fileinput> <patcharrayfile> <interval> <mode> <fileoutput>")
	print("Available modes: fw | bw | rnd")
	sys.exit()


#Primer obrim el patcharray per obtenir les duples:

p_h = open (p, "r")
pa = p_h.readlines() #D'una tacada fiquem totes les linies en una llista (array)
p_h.close()

print ("Llegint PatchArray " + p)

#Ordenem el patcharray segons l'ordre especificat a <mode>

if m == "fw" :
	
	#No cal tocar res, es el mode "default"
	print ("Draining bytes in lineal order (fw)")
	pass

elif m == "bw" :
	
	#En backwards donem la volta a la llista
	print ("Draining bytes in inverse order(bw)")
	pa.reverse()
	
elif m == "rnd" :

	#En random, aleatoritzem la llista
	print ("Draining bytes in random order (rnd)")
	shuffle(pa)

else :
	print("Need to specify a restoring order: fw | bw | rnd")
	sys.exit()



def pause() :

	while True:
		if keyboard.is_pressed("\u0020"):
		
			print ("Unpaused")
			return()
		
#Llegim i

i_h = open (i, "rb")
data = i_h.read()
i_h.close()


#Creem un nou arxiu i ho copiem tot

o_h = open(o, "wb")
o_h.write(data)

# print ("Press [SPACE] for pausing, [ENTER] for stopping  (to-do)")

# "Drenem" els bytes a l'arxiu

c=0 # c per a count

while c < len(pa) :
	
	#if keyboard.is_pressed("\u0020"): # Pause
	#	print("Draining Paused")
	#	pause()
		
	sys.stdout.write( o + "<---------Draining byte " + str(c) + "/" + str(len(pa)) + "<-------" + i )
	
	byte_offset = int(pa[c].split(",")[0])
	byte_value = int(pa[c].split(",")[1])
	
	#print ("\nOffset: " + str(byte_offset) + ", Value: " + str(byte_value))
	
	o_h.seek(byte_offset)
	o_h.write(bytes([byte_value])) # Amb aquesta funció convertim el valor INT directament en bin per la seva escriptura
	
	o_h.flush()
	
	
	sys.stdout.write('\r')
	
	time.sleep(t)
	
	c += 1
	
o_h.close()

sys.stdout.write( o + "<------Draining byte " + str(c) + "/" + str(len(pa)) + "<-----" + i )
print ("\Byte draining finished :)")
	
	
